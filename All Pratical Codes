
Program 1(B) : 
 
#!/bin/bash 
 
ADDRESS_BOOK="address_book.txt" 
 
# Function to create/reset address book 
create_address_book() { 
    > "$ADDRESS_BOOK" 
    echo "Address book created/reset successfully." 
} 
 
# Function to view address book 
view_address_book() { 
    if [ ! -s "$ADDRESS_BOOK" ]; then 
        echo "Address book is empty." 
    else 
        echo "------ Address Book ------" 
        cat "$ADDRESS_BOOK" 
        echo "--------------------------" 
    fi 
} 
 
# Function to insert a record 
insert_record() { 
    echo "Enter Name:" 
    read name 
    echo "Enter Phone Number:" 
    read phone 
    echo "Enter Email:" 
    read email 
    echo "$name | $phone | $email" >> "$ADDRESS_BOOK" 
    echo "Record added successfully." 
} 
 
# Function to delete a record by name 
delete_record() { 
    echo "Enter the name of the record to delete:" 
    read name 
    if grep -Fq "$name |" "$ADDRESS_BOOK"; then 
        grep -Fv "$name |" "$ADDRESS_BOOK" > temp.txt && mv temp.txt "$ADDRESS_BOOK" 
        echo "Record deleted." 
    else 
        echo "Record not found." 
    fi 
} 
 
# Function to modify a record by name 
modify_record() { 
    echo "Enter the name of the record to modify:" 
    read name 
    if grep -Fq "$name |" "$ADDRESS_BOOK"; then 
        echo "Enter new phone number:" 
        read phone 
        echo "Enter new email:" 
        read email 
        grep -Fv "$name |" "$ADDRESS_BOOK" > temp.txt 
        echo "$name | $phone | $email" >> temp.txt 
        mv temp.txt "$ADDRESS_BOOK" 
        echo "Record updated." 
    else 
        echo "Record not found." 
    fi 
} 
 
# Main menu loop 
while true; do 
    echo "" 
    echo "Address Book Menu:" 
    echo "a) Create address book" 
    echo "b) View address book" 
    echo "c) Insert a record" 
    echo "d) Delete a record" 
    echo "e) Modify a record" 
    echo "f) Exit" 
    echo "Choose an option:" 
    read choice 
    case $choice in 
        a) create_address_book ;; 
        b) view_address_book ;; 
        c) insert_record ;; 
        d) delete_record ;; 
        e) modify_record ;; 
        f) echo "Exiting..."; exit 0 ;; 
        *) echo "Invalid option. Try again." ;; 
    esac 
done


-----------------------------------------------------------------------------------------------------------------------------------

Program 2(A) : 
 
 
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int split(int[], int, int);
void quickSort(int*, int, int);
void mergeSort(int[], int, int, int);
void partition(int[], int, int);
void display(int[], int);

void mergeSort(int arr[], int low, int mid, int high) {
    int i, j, k, l, b[20];
    l = low;
    i = low;
    j = mid + 1;

    while ((l <= mid) && (j <= high)) {
        if (arr[l] <= arr[j]) {
            b[i] = arr[l];
            l++;
        } else {
            b[i] = arr[j];
            j++;
        }
        i++;
    }

    if (l > mid) {
        for (k = j; k <= high; k++) {
            b[i] = arr[k];
            i++;
        }
    } else {
        for (k = l; k <= mid; k++) {
            b[i] = arr[k];
            i++;
        }
    }

    for (k = low; k <= high; k++) {
        arr[k] = b[k];
    }
}

void partition(int arr[], int low, int high) {
    int mid;
    if (low < high) {
        mid = (low + high) / 2;
        partition(arr, low, mid);
        partition(arr, mid + 1, high);
        mergeSort(arr, low, mid, high);
    }
}

void display(int a[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d\t", a[i]);
    }
    printf("\n");
}

int main() {
    int pid, child_pid;
    int size, i;

    printf("Enter the number of Integers to Sort: ");
    scanf("%d", &size);

    int a[size];
    int pArr[size];
    int cArr[size];

    for (i = 0; i < size; i++) {
        printf("Enter number %d: ", (i + 1));
        scanf("%d", &a[i]);
        pArr[i] = a[i];
        cArr[i] = a[i];
    }

    printf("\nYour Entered Integers for Sorting:\n");
    display(a, size);

    pid = getpid();
    printf("Current Process ID is : %d\n", pid);
    printf("[ Forking Child Process ... ]\n");
    child_pid = fork();

    if (child_pid < 0) {
        printf("\nChild Process Creation Failed!\n");
        exit(-1);
    } else if (child_pid == 0) {
        printf("\n--- Child Process ---\n");
        printf("Child PID: %d | Parent PID: %d\n", getpid(), getppid());
        printf("Child is sorting using QUICK SORT...\n");
        quickSort(cArr, 0, size - 1);
        printf("Sorted list by Child:\n");
        display(cArr, size);
        printf("Child Process Completed.\n");
        sleep(5);
        printf("Parent of Child after sleep: %d\n", getppid());
    } else {
        printf("\n--- Parent Process ---\n");
        printf("Parent PID: %d | Its Parent: %d\n", getpid(), getppid());
        sleep(10);
        printf("Parent sorting using MERGE SORT...\n");
        partition(pArr, 0, size - 1);
        printf("Sorted list by Parent:\n");
        display(pArr, size);
        printf("Parent Process Completed.\n");
    }

    return 0;
}

int split(int a[], int lower, int upper) {
    int i, p, q, t;
    p = lower + 1;
    q = upper;
    i = a[lower];

    while (p <= q) {
        while (a[p] < i && p <= upper) p++;
        while (a[q] > i && q >= lower) q--;
        if (p < q) {
            t = a[p];
            a[p] = a[q];
            a[q] = t;
            p++; q--;
        } else break;
    }

    t = a[lower];
    a[lower] = a[q];
    a[q] = t;

    return q;
}

void quickSort(int a[], int lower, int upper) {
    int i;
    if (upper > lower) {
        i = split(a, lower, upper);
        quickSort(a, lower, i - 1);
        quickSort(a, i + 1, upper);
    }
}


---------------------------------------------------------------------------------------------------------------


Program 2(B) : 
Parent code - 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

// Function to perform Bubble Sort
void bubbleSort(int arr[], int n)
{
    printf("\nSorting Started\n");
    for (int i = 0; i < n - 1; i++)
    {
        for (int j = 0; j < n - 1 - i; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    printf("Sorting Completed!\n");
}

// Convert integer to string
void tostring(char str[], int num)
{
    sprintf(str, "%d", num);
}

int main()
{
    printf("\nThis is the main process");
    printf("\nProcess ID: %d", getpid());
    printf("\nParent ID: %d\n", getppid());

    int arr[] = {10, 5, 1, 60, 20};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("\nSorting array using Bubble Sort:\n");
    bubbleSort(arr, n);

    printf("Sorted array: ");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");

    printf("\nForking the current process...\n");

    pid_t cpid = fork();

    if (cpid > 0)
    {
        // Parent process
        printf("\nParent is running:\nParent ID: %d\nIts ID: %d\n", getppid(), getpid());
        printf("Parent is waiting for child to complete...\n");
        wait(NULL);
        printf("Parent exiting...\n");
    }
    else if (cpid == 0)
    {
        // Child process
        printf("\nChild is running:\nParent ID: %d\nIts ID: %d\n", getppid(), getpid());

        // Prepare arguments for execv
        char *arrChar[n + 2];
        arrChar[0] = "./child"; // program name

        for (int i = 0; i < n; i++)
        {
            char *string = malloc(20 * sizeof(char));
            tostring(string, arr[i]);
            arrChar[i + 1] = string;
        }
        arrChar[n + 1] = NULL;

        printf("\nChild calling execv system call...\n");
        execv("./child", arrChar);

        // If execv fails
        perror("execv failed");

        for (int i = 1; i <= n; i++)
            free(arrChar[i]);
        exit(EXIT_FAILURE);
    }
    else
    {
        perror("fork failed");
        exit(EXIT_FAILURE);
    }

    return 0;
}



child-------------->

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    if (argc < 2)
    {
        printf("No numbers passed to child.\n");
        return 1;
    }

    int *data = (int *)malloc((argc - 1) * sizeof(int));
    printf("\nChild program received %d arguments\n", argc - 1);

    for (int i = 1; i < argc; i++)
        data[i - 1] = atoi(argv[i]);

    // Print elements in reverse order
    printf("Printing elements in reverse order:\n");
    for (int i = argc - 2; i >= 0; i--)
        printf("%d ", data[i]);
    printf("\n\nexecv task completed\n");

    free(data);
    return 0;
}


----------------------------------------------------------------------------------------------------------------------------------------------------------

3 A


SRTF
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

struct Process {
    int pid;              // Process ID
    int arrival_time;
    int burst_time;
    int remaining_time;
    int completion_time;
    int waiting_time;
    int turnaround_time;
};

void srtf(struct Process proc[], int n) {
    int current_time = 0;
    int completed_processes = 0;
    int min_remaining_time_index = -1;
    int min_remaining_time = INT_MAX;
    int is_idle = 1; // Flag to check if CPU is idle

    printf("\nGantt Chart:\n");

    while (completed_processes < n) {
        min_remaining_time_index = -1;
        min_remaining_time = INT_MAX;
        is_idle = 1;

        // Find process with the shortest remaining time among arrived processes
        for (int i = 0; i < n; i++) {
            if (proc[i].arrival_time <= current_time && proc[i].remaining_time > 0) {
                if (proc[i].remaining_time < min_remaining_time) {
                    min_remaining_time = proc[i].remaining_time;
                    min_remaining_time_index = i;
                    is_idle = 0;
                }
            }
        }

        // If CPU is idle, increment time
        if (is_idle) {
            current_time++;
            printf(" | Idle |");
            continue;
        }

        // Execute selected process for one time unit
        proc[min_remaining_time_index].remaining_time--;
        current_time++;
        printf(" | P%d |", proc[min_remaining_time_index].pid);

        // If process completes
        if (proc[min_remaining_time_index].remaining_time == 0) {
            proc[min_remaining_time_index].completion_time = current_time;
            proc[min_remaining_time_index].turnaround_time =
                proc[min_remaining_time_index].completion_time - proc[min_remaining_time_index].arrival_time;
            proc[min_remaining_time_index].waiting_time =
                proc[min_remaining_time_index].turnaround_time - proc[min_remaining_time_index].burst_time;
            completed_processes++;
        }
    }

    // Calculate and print results
    float avg_waiting_time = 0;
    float avg_turnaround_time = 0;

    printf("\n\nProcess\tArrival Time\tBurst Time\tCompletion Time\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t%d\t\t%d\t\t%d\t\t%d\t\t%d\n",
               proc[i].pid, proc[i].arrival_time, proc[i].burst_time,
               proc[i].completion_time, proc[i].waiting_time, proc[i].turnaround_time);

        avg_waiting_time += proc[i].waiting_time;
        avg_turnaround_time += proc[i].turnaround_time;
    }

    avg_waiting_time /= n;
    avg_turnaround_time /= n;

    printf("\nAverage Waiting Time: %.2f\n", avg_waiting_time);
    printf("Average Turnaround Time: %.2f\n", avg_turnaround_time);
}

int main() {
    int n;
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct Process proc[n];

    for (int i = 0; i < n; i++) {
        proc[i].pid = i + 1;
        printf("Enter arrival time for P%d: ", i + 1);
        scanf("%d", &proc[i].arrival_time);
        printf("Enter burst time for P%d: ", i + 1);
        scanf("%d", &proc[i].burst_time);
        proc[i].remaining_time = proc[i].burst_time;
    }

    srtf(proc, n);
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------------------

3B	

Round Robin : 
#include <stdio.h>

struct Process {
    int pid;              // Process ID
    int arrival_time;
    int burst_time;
    int remaining_time;
    int completion_time;
    int waiting_time;
    int turnaround_time;
};

void round_robin(struct Process proc[], int n, int quantum) {
    int current_time = 0, completed = 0;
    int done;

    printf("\nGantt Chart:\n");

    while (completed < n) {
        done = 1; // Assume all done unless found otherwise

        for (int i = 0; i < n; i++) {
            if (proc[i].arrival_time <= current_time && proc[i].remaining_time > 0) {
                done = 0;

                if (proc[i].remaining_time > quantum) {
                    printf(" | P%d |", proc[i].pid);
                    current_time += quantum;
                    proc[i].remaining_time -= quantum;
                } else {
                    printf(" | P%d |", proc[i].pid);
                    current_time += proc[i].remaining_time;
                    proc[i].completion_time = current_time;
                    proc[i].turnaround_time = proc[i].completion_time - proc[i].arrival_time;
                    proc[i].waiting_time = proc[i].turnaround_time - proc[i].burst_time;
                    proc[i].remaining_time = 0;
                    completed++;
                }
            }
        }

        if (done) {
            printf(" | Idle |");
            current_time++;
        }
    }

    // Print results
    float avg_wt = 0, avg_tat = 0;
    printf("\n\nProcess\tArrival\tBurst\tCompletion\tWaiting\tTurnaround\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\t\t%d\t%d\n",
               proc[i].pid,
               proc[i].arrival_time,
               proc[i].burst_time,
               proc[i].completion_time,
               proc[i].waiting_time,
               proc[i].turnaround_time);
        avg_wt += proc[i].waiting_time;
        avg_tat += proc[i].turnaround_time;
    }

    printf("\nAverage Waiting Time: %.2f", avg_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", avg_tat / n);
}

int main() {
    int n, quantum;

    printf("Enter number of processes: ");
    scanf("%d", &n);
    printf("Enter time quantum: ");
    scanf("%d", &quantum);

    struct Process proc[n];

    for (int i = 0; i < n; i++) {
        proc[i].pid = i + 1;
        printf("Enter arrival time for P%d: ", i + 1);
        scanf("%d", &proc[i].arrival_time);
        printf("Enter burst time for P%d: ", i + 1);
        scanf("%d", &proc[i].burst_time);
        proc[i].remaining_time = proc[i].burst_time;
    }

    round_robin(proc, n, quantum);
    return 0;
}


------------------------------------------------------------------------------------------------------------------------------------


4 A



#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <semaphore.h>
#include <unistd.h>

#define BUFFER_SIZE 10

sem_t full, empty;
pthread_mutex_t mutex;
int buffer[BUFFER_SIZE];
int counter;

void *producer(void *p);
void *consumer(void *p);
void insert_item(int item);
int remove_item();
void initialize();

void initialize() {
    pthread_mutex_init(&mutex, NULL);
    sem_init(&full, 0, 0);
    sem_init(&empty, 0, BUFFER_SIZE);
    counter = 0;
}

int main() {
    int n1, n2, i;

    printf("\nEnter no. of producers you want to create: ");
    scanf("%d", &n1);
    printf("Enter no. of consumers you want to create: ");
    scanf("%d", &n2);

    initialize();

    pthread_t producers[n1], consumers[n2];

    for (i = 0; i < n1; i++)
        pthread_create(&producers[i], NULL, producer, NULL);

    for (i = 0; i < n2; i++)
        pthread_create(&consumers[i], NULL, consumer, NULL);

    // Wait for threads (though in infinite loops, you can replace with sleep)
    sleep(30);
    printf("\n\nMain exiting...\n");
    return 0;
}

void *producer(void *p) {
    while (1) {
        int item = rand() % 100;
        int waittime = rand() % 5;
        sleep(waittime);

        sem_wait(&empty);
        pthread_mutex_lock(&mutex);

        insert_item(item);
        printf("\nProducer produced item %d | Buffer count: %d", item, counter);
        fflush(stdout);

        pthread_mutex_unlock(&mutex);
        sem_post(&full);
    }
}

void *consumer(void *p) {
    while (1) {
        int waittime = rand() % 8;
        sleep(waittime);

        sem_wait(&full);
        pthread_mutex_lock(&mutex);

        int item = remove_item();
        printf("\nConsumer consumed item %d | Buffer count: %d", item, counter);
        fflush(stdout);

        pthread_mutex_unlock(&mutex);
        sem_post(&empty);
    }
}

void insert_item(int item) {
    if (counter < BUFFER_SIZE)
        buffer[counter++] = item;
}

int remove_item() {
    if (counter > 0)
        return buffer[--counter];
    return -1;
}


-----------------------------------------------------------------------------------------------------------------------------




Program 4(B): 



#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

sem_t mutex;   // Semaphore for controlling readcount access
sem_t wrt;     // Semaphore for controlling writer access
int readcount = 0; // Number of active readers
int nrd, nwt;

// Reader thread function
void *reader_thr(void *arg) {
    int temp = *(int *)arg;

    printf("\nReader %d is trying to enter database for reading.", temp);
    fflush(stdout);

    sem_wait(&mutex);
    readcount++;
    if (readcount == 1)
        sem_wait(&wrt); // First reader locks writer access
    sem_post(&mutex);

    printf("\nReader %d is now READING the database.", temp);
    fflush(stdout);
    sleep(2); // Simulate reading

    sem_wait(&mutex);
    readcount--;
    if (readcount == 0)
        sem_post(&wrt); // Last reader releases writer access
    sem_post(&mutex);

    printf("\nReader %d has LEFT the database.\n", temp);
    fflush(stdout);

    return NULL;
}

// Writer thread function
void *writer_thr(void *arg) {
    int temp = *(int *)arg;

    printf("\nWriter %d is trying to enter database for writing.", temp);
    fflush(stdout);

    sem_wait(&wrt);
    printf("\nWriter %d is WRITING to the database.", temp);
    fflush(stdout);
    sleep(3); // Simulate writing
    printf("\nWriter %d has LEFT the database.\n", temp);
    fflush(stdout);
    sem_post(&wrt);

    return NULL;
}

int main() {
    sem_init(&mutex, 0, 1);
    sem_init(&wrt, 0, 1);

    printf("Enter number of readers: ");
    scanf("%d", &nrd);
    printf("Enter number of writers: ");
    scanf("%d", &nwt);

    pthread_t readers[nrd], writers[nwt];
    int r_ids[nrd], w_ids[nwt];

    // Create writer threads
    for (int i = 0; i < nwt; i++) {
        w_ids[i] = i + 1;
        pthread_create(&writers[i], NULL, writer_thr, &w_ids[i]);
        sleep(1); // small delay to interleave
    }

    // Create reader threads
    for (int i = 0; i < nrd; i++) {
        r_ids[i] = i + 1;
        pthread_create(&readers[i], NULL, reader_thr, &r_ids[i]);
        sleep(1);
    }

    // Wait for all threads to finish
    for (int i = 0; i < nwt; i++)
        pthread_join(writers[i], NULL);
    for (int i = 0; i < nrd; i++)
        pthread_join(readers[i], NULL);

    sem_destroy(&mutex);
    sem_destroy(&wrt);

    printf("\nAll readers and writers have finished.\n");
    return 0;
}







--------------------------------------------------------------------------------------------------------------------------------------

Program 5 



Bankers Algorithm : 
#include <stdio.h>
#include <stdbool.h>

#define MAX_PROCESSES 10
#define MAX_RESOURCES 10

int main() {
    int n, m;
    int allocation[MAX_PROCESSES][MAX_RESOURCES];
    int maximum[MAX_PROCESSES][MAX_RESOURCES];
    int available[MAX_RESOURCES];
    int need[MAX_PROCESSES][MAX_RESOURCES];
    bool finish[MAX_PROCESSES] = {false};
    int safeSequence[MAX_PROCESSES];
    int work[MAX_RESOURCES];

    // Input number of processes and resources
    printf("Enter the number of processes: ");
    scanf("%d", &n);
    printf("Enter the number of resources: ");
    scanf("%d", &m);

    // Input available resources
    printf("\nEnter the available resources (space-separated):\n");
    for (int i = 0; i < m; i++) {
        scanf("%d", &available[i]);
        work[i] = available[i];
    }

    // Input maximum demand matrix
    printf("\nEnter the maximum demand matrix:\n");
    for (int i = 0; i < n; i++) {
        printf("For Process P%d: ", i);
        for (int j = 0; j < m; j++) {
            scanf("%d", &maximum[i][j]);
        }
    }

    // Input allocation matrix and calculate need matrix
    printf("\nEnter the allocation matrix:\n");
    for (int i = 0; i < n; i++) {
        printf("For Process P%d: ", i);
        for (int j = 0; j < m; j++) {
            scanf("%d", &allocation[i][j]);
            need[i][j] = maximum[i][j] - allocation[i][j];
        }
    }

    // Display the Need matrix
    printf("\nNeed Matrix:\n");
    for (int i = 0; i < n; i++) {
        printf("P%d: ", i);
        for (int j = 0; j < m; j++) {
            printf("%d ", need[i][j]);
        }
        printf("\n");
    }

    // Safety algorithm
    int count = 0;
    while (count < n) {
        bool found = false;

        for (int i = 0; i < n; i++) {
            if (!finish[i]) {
                bool canAllocate = true;

                for (int j = 0; j < m; j++) {
                    if (need[i][j] > work[j]) {
                        canAllocate = false;
                        break;
                    }
                }

                if (canAllocate) {
                    for (int j = 0; j < m; j++) {
                        work[j] += allocation[i][j];
                    }

                    safeSequence[count++] = i;
                    finish[i] = true;
                    found = true;
                }
            }
        }

        if (!found) {
            printf("\nThe system is NOT in a safe state.\n");
            return 0;
        }
    }

    // Display result
    printf("\nThe system is in a SAFE state.\nSafe sequence is: ");
    for (int i = 0; i < n; i++) {
        printf("P%d ", safeSequence[i]);
    }
    printf("\n");

    return 0;
}





------------------------------------------------------------------------------------------------------------------------------------------------



Program 6 



Page Replacement : 
#include <stdio.h>
#include <stdlib.h>

int n, nf;
int in[100];
int p[50];
int hit = 0;
int i, j, k;
int pgfaultcnt = 0;

void getData() {
    printf("\nEnter length of page reference sequence: ");
    scanf("%d", &n);
    printf("\nEnter the page reference sequence: ");
    for (i = 0; i < n; i++)
        scanf("%d", &in[i]);
    printf("\nEnter number of frames: ");
    scanf("%d", &nf);
}

void initialize() {
    pgfaultcnt = 0;
    for (i = 0; i < nf; i++)
        p[i] = 9999;
}

int isHit(int data) {
    hit = 0;
    for (j = 0; j < nf; j++) {
        if (p[j] == data) {
            hit = 1;
            break;
        }
    }
    return hit;
}

int getHitIndex(int data) {
    int hitind = -1;
    for (k = 0; k < nf; k++) {
        if (p[k] == data) {
            hitind = k;
            break;
        }
    }
    return hitind;
}

void dispPages() {
    printf("  Frames: ");
    for (k = 0; k < nf; k++) {
        if (p[k] != 9999)
            printf("%d ", p[k]);
        else
            printf("- ");
    }
    printf("\n");
}

void dispPgFaultCnt() {
    printf("\nTotal number of page faults: %d\n", pgfaultcnt);
}

/* ---------- FIFO ---------- */
void fifo() {
    initialize();
    printf("\n--- FIFO Page Replacement ---\n");
    for (i = 0; i < n; i++) {
        printf("\nFor %d :", in[i]);
        if (isHit(in[i]) == 0) {
            for (k = 0; k < nf - 1; k++)
                p[k] = p[k + 1];
            p[k] = in[i];
            pgfaultcnt++;
            dispPages();
        } else
            printf(" No page fault!");
    }
    dispPgFaultCnt();
}

/* ---------- OPTIMAL ---------- */
void optimal() {
    initialize();
    printf("\n--- OPTIMAL Page Replacement ---\n");
    int near[50];

    for (i = 0; i < n; i++) {
        printf("\nFor %d :", in[i]);
        if (isHit(in[i]) == 0) {
            for (j = 0; j < nf; j++) {
                int pg = p[j];
                int found = 0;
                for (k = i; k < n; k++) {
                    if (pg == in[k]) {
                        near[j] = k;
                        found = 1;
                        break;
                    }
                }
                if (!found)
                    near[j] = 9999;
            }

            int max = -9999, repindex = -1;
            for (j = 0; j < nf; j++) {
                if (near[j] > max) {
                    max = near[j];
                    repindex = j;
                }
            }

            p[repindex] = in[i];
            pgfaultcnt++;
            dispPages();
        } else
            printf(" No page fault!");
    }
    dispPgFaultCnt();
}

/* ---------- LRU ---------- */
void lru() {
    initialize();
    printf("\n--- LRU Page Replacement ---\n");
    int least[50];

    for (i = 0; i < n; i++) {
        printf("\nFor %d :", in[i]);
        if (isHit(in[i]) == 0) {
            for (j = 0; j < nf; j++) {
                int pg = p[j];
                int found = 0;
                for (k = i - 1; k >= 0; k--) {
                    if (pg == in[k]) {
                        least[j] = k;
                        found = 1;
                        break;
                    }
                }
                if (!found)
                    least[j] = -9999;
            }

            int min = 9999, repindex = -1;
            for (j = 0; j < nf; j++) {
                if (least[j] < min) {
                    min = least[j];
                    repindex = j;
                }
            }

            p[repindex] = in[i];
            pgfaultcnt++;
            dispPages();
        } else
            printf(" No page fault!");
    }
    dispPgFaultCnt();
}

/* ---------- SECOND CHANCE ---------- */
void secondchance() {
    printf("\n--- SECOND CHANCE Page Replacement ---\n");
    int usedbit[50];
    int victimptr = 0;

    initialize();
    for (i = 0; i < nf; i++)
        usedbit[i] = 0;

    for (i = 0; i < n; i++) {
        printf("\nFor %d :", in[i]);
        if (isHit(in[i])) {
            printf(" No page fault!");
            int hitindex = getHitIndex(in[i]);
            usedbit[hitindex] = 1;
        } else {
            pgfaultcnt++;
            while (usedbit[victimptr] == 1) {
                usedbit[victimptr] = 0;
                victimptr++;
                if (victimptr == nf)
                    victimptr = 0;
            }
            p[victimptr] = in[i];
            usedbit[victimptr] = 1;
            victimptr++;
            if (victimptr == nf)
                victimptr = 0;
            dispPages();
        }
    }
    dispPgFaultCnt();
}

/* ---------- MAIN MENU ---------- */
int main() {
    int choice;

    while (1) {
        printf("\n===============================");
        printf("\n Page Replacement Algorithms");
        printf("\n===============================");
        printf("\n1. Enter data");
        printf("\n2. FIFO");
        printf("\n3. Optimal");
        printf("\n4. LRU");
        printf("\n5. Second Chance");
        printf("\n6. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                getData();
                break;
            case 2:
                fifo();
                break;
            case 3:
                optimal();
                break;
            case 4:
                lru();
                break;
            case 5:
                secondchance();
                break;
            case 6:
                exit(0);
            default:
                printf("\nInvalid choice! Try again.\n");
        }
    }
}


-------------------------------------------------------------------------------------------------------------------------------------------------




PRACTICAL 7 A


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <fcntl.h>

#define MAX_LEN 1024
#define FILE_NAME "output.txt"

// Function to count characters, words, and lines
void count_data(const char *input, int *char_count, int *word_count, int *line_count) {
    *char_count = *word_count = *line_count = 0;
    int in_word = 0;

    for (int i = 0; input[i] != '\0'; i++) {
        (*char_count)++;

        if (input[i] == '\n')
            (*line_count)++;

        if (input[i] == ' ' || input[i] == '\n' || input[i] == '\t') {
            in_word = 0;
        } else if (in_word == 0) {
            in_word = 1;
            (*word_count)++;
        }
    }

    // If no newline at end, still count it as a line
    if (*char_count > 0 && input[strlen(input) - 1] != '\n') {
        (*line_count)++;
    }
}

int main() {
    int pipe1[2]; // From parent to child
    int pipe2[2]; // From child to parent
    pid_t pid;

    char input[MAX_LEN];
    char result[MAX_LEN];

    // Create pipes
    if (pipe(pipe1) == -1 || pipe(pipe2) == -1) {
        perror("Pipe creation failed");
        exit(1);
    }

    pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    }

    if (pid > 0) {
        // === Parent Process ===
        close(pipe1[0]); // Close read end of pipe1
        close(pipe2[1]); // Close write end of pipe2

        printf("Enter a sentence (end with ENTER):\n");
        fgets(input, MAX_LEN, stdin);

        // Send input to child
        write(pipe1[1], input, strlen(input) + 1);
        close(pipe1[1]); // Close write end after sending

        // Read result from child
        ssize_t bytes = read(pipe2[0], result, MAX_LEN - 1);
        result[bytes] = '\0'; // Ensure string terminator
        close(pipe2[0]); // Close read end

        // Display result
        printf("\n=== Analysis Result from Child Process ===\n");
        printf("%s\n", result);
    } else {
        // === Child Process ===
        close(pipe1[1]); // Close write end of pipe1
        close(pipe2[0]); // Close read end of pipe2

        char buffer[MAX_LEN];
        char result[MAX_LEN];
        int char_count, word_count, line_count;

        // Read input from parent
        ssize_t bytes = read(pipe1[0], buffer, MAX_LEN - 1);
        buffer[bytes] = '\0'; // Ensure string terminator
        close(pipe1[0]); // Close read end

        // Perform analysis
        count_data(buffer, &char_count, &word_count, &line_count);

        // Write result to file
        FILE *fp = fopen(FILE_NAME, "w");
        if (!fp) {
            perror("File open failed");
            exit(1);
        }

        fprintf(fp, "Characters: %d\nWords: %d\nLines: %d\n", char_count, word_count, line_count);
        fclose(fp);

        // Read from file and send to parent
        fp = fopen(FILE_NAME, "r");
        if (!fp) {
            perror("File read failed");
            exit(1);
        }

        int bytes_read = fread(result, sizeof(char), MAX_LEN - 1, fp);
        result[bytes_read] = '\0';
        fclose(fp);

        write(pipe2[1], result, strlen(result) + 1);
        close(pipe2[1]); // Close write end

        // Optional: clean up file
        remove(FILE_NAME);
    }

    return 0;
}



----------------------------------------------------------------------------------------------------------------------------------------------------

7 B



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>

#define SHM_KEY  0x1234
#define SHM_SIZE 1024

static void run_server(void) {
    // Create shared memory
    int shmid = shmget(SHM_KEY, SHM_SIZE, 0666 | IPC_CREAT);
    if (shmid == -1) {
        perror("Server: shmget failed");
        exit(EXIT_FAILURE);
    }

    // Attach to shared memory
    char *shared_mem = (char *)shmat(shmid, NULL, 0);
    if (shared_mem == (char *)-1) {
        perror("Server: shmat failed");
        exit(EXIT_FAILURE);
    }

    // Optional: clear the region
    memset(shared_mem, 0, SHM_SIZE);

    // Write a message (force NUL-termination)
    const char *message = "Hello from server!";
    strncpy(shared_mem, message, SHM_SIZE - 1);
    shared_mem[SHM_SIZE - 1] = '\0';

    printf("Server: Message written to shared memory.\n");

    // Detach
    if (shmdt(shared_mem) == -1) {
        perror("Server: shmdt failed");
        exit(EXIT_FAILURE);
    }
}

static void run_client(void) {
    // Access shared memory
    int shmid = shmget(SHM_KEY, SHM_SIZE, 0666);
    if (shmid == -1) {
        perror("Client: shmget failed (did you run server first?)");
        exit(EXIT_FAILURE);
    }

    // Attach to shared memory
    char *shared_mem = (char *)shmat(shmid, NULL, 0);
    if (shared_mem == (char *)-1) {
        perror("Client: shmat failed");
        exit(EXIT_FAILURE);
    }

    // Read message
    printf("Client: Message from server: %s\n", shared_mem);

    // Detach
    if (shmdt(shared_mem) == -1) {
        perror("Client: shmdt failed");
        exit(EXIT_FAILURE);
    }

    // Remove shared memory (cleanup)
    if (shmctl(shmid, IPC_RMID, NULL) == -1) {
        perror("Client: shmctl(IPC_RMID) failed");
        exit(EXIT_FAILURE);
    }
}

int main(void) {
    int choice;
    printf("Select mode:\n1. Server\n2. Client\nEnter choice: ");
    if (scanf("%d", &choice) != 1) {
        fprintf(stderr, "Invalid input.\n");
        return EXIT_FAILURE;
    }

    if (choice == 1) {
        run_server();
    } else if (choice == 2) {
        run_client();
    } else {
        printf("Invalid choice.\n");
    }

    return EXIT_SUCCESS;
}






----------------------------------------------------------------------------------------------------------------------------------------------


8 





#include <stdio.h>
#include <stdlib.h>

#define INF 1000000

// Utility: simple bubble sort
void sortArray(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// ---------- SSTF Algorithm ----------
int findClosestRequest(int requests[], int n, int head, int visited[]) {
    int minDistance = INF;
    int index = -1;
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            int distance = abs(requests[i] - head);
            if (distance < minDistance) {
                minDistance = distance;
                index = i;
            }
        }
    }
    return index;
}

void SSTF(int requests[], int n, int head) {
    int visited[n];
    for (int i = 0; i < n; i++) visited[i] = 0;

    int totalSeek = 0;
    int currentHead = head;

    printf("\n--- SSTF Disk Scheduling ---\n");
    printf("Initial Head Position: %d\nSeek Sequence: %d ", head, head);

    for (int i = 0; i < n; i++) {
        int nextIndex = findClosestRequest(requests, n, currentHead, visited);
        visited[nextIndex] = 1;
        totalSeek += abs(requests[nextIndex] - currentHead);
        currentHead = requests[nextIndex];
        printf("-> %d ", currentHead);
    }

    printf("\nTotal Seek Time: %d\n", totalSeek);
}

// ---------- SCAN Algorithm ----------
void SCAN(int requests[], int n, int head, int diskSize) {
    int totalSeek = 0;
    int currentHead = head;

    int left[n], right[n];
    int leftCount = 0, rightCount = 0;

    // Divide requests into left and right relative to head
    for (int i = 0; i < n; i++) {
        if (requests[i] >= head)
            right[rightCount++] = requests[i];
        else
            left[leftCount++] = requests[i];
    }

    // Sort left and right arrays
    sortArray(left, leftCount);
    sortArray(right, rightCount);

    printf("\n--- SCAN Disk Scheduling (Right then Left) ---\n");
    printf("Initial Head Position: %d\nSeek Sequence: %d ", head, currentHead);

    // Move right (towards higher cylinders)
    for (int i = 0; i < rightCount; i++) {
        totalSeek += abs(right[i] - currentHead);
        currentHead = right[i];
        printf("-> %d ", currentHead);
    }

    // Go to end of disk
    if (currentHead != diskSize - 1) {
        totalSeek += abs((diskSize - 1) - currentHead);
        currentHead = diskSize - 1;
        printf("-> %d ", currentHead);
    }

    // Move left
    for (int i = leftCount - 1; i >= 0; i--) {
        totalSeek += abs(left[i] - currentHead);
        currentHead = left[i];
        printf("-> %d ", currentHead);
    }

    printf("\nTotal Seek Time: %d\n", totalSeek);
}

// ---------- C-LOOK Algorithm ----------
void C_LOOK(int requests[], int n, int head) {
    int totalSeek = 0;
    int currentHead = head;

    int left[n], right[n];
    int leftCount = 0, rightCount = 0;

    // Divide requests relative to head
    for (int i = 0; i < n; i++) {
        if (requests[i] >= head)
            right[rightCount++] = requests[i];
        else
            left[leftCount++] = requests[i];
    }

    // Sort both arrays
    sortArray(left, leftCount);
    sortArray(right, rightCount);

    printf("\n--- C-LOOK Disk Scheduling (Cyclic) ---\n");
    printf("Initial Head Position: %d\nSeek Sequence: %d ", head, currentHead);

    // Move right first
    for (int i = 0; i < rightCount; i++) {
        totalSeek += abs(right[i] - currentHead);
        currentHead = right[i];
        printf("-> %d ", currentHead);
    }

    // Jump to the lowest request
    if (leftCount > 0) {
        totalSeek += abs(currentHead - left[0]); // jump from last right to first left
        currentHead = left[0];
        printf("-> %d ", currentHead);

        // Continue left-to-right
        for (int i = 1; i < leftCount; i++) {
            totalSeek += abs(left[i] - currentHead);
            currentHead = left[i];
            printf("-> %d ", currentHead);
        }
    }

    printf("\nTotal Seek Time: %d\n", totalSeek);
}

// ---------- Main ----------
int main() {
    int n, head, diskSize;

    printf("Enter number of requests: ");
    scanf("%d", &n);

    int requests[n];
    printf("Enter the requests (cylinder numbers): ");
    for (int i = 0; i < n; i++)
        scanf("%d", &requests[i]);

    printf("Enter initial head position: ");
    scanf("%d", &head);

    printf("Enter disk size (number of cylinders): ");
    scanf("%d", &diskSize);

    SSTF(requests, n, head);
    SCAN(requests, n, head, diskSize);
    C_LOOK(requests, n, head);

    return 0;
}

